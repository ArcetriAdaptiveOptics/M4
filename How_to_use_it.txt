• Acquisizione ed analisi delle Funzioni d'influenza


	- Acquisizione
	
	  PROCEDIMENTO:
	  from m4.utils import create_device
      device = create_device.myDevice("segment") 		#or "m4"
      from m4.influence_functions_maker import IFFunctionsMaker
      IFF = IFFunctionsMaker(device) 
      tt = IFF.acq_IFFunctions(modesVectorFitsFileName, nPushPull, amplitudeFitsFileName,
      							 cmdMatrixFitsFileName, shuffle=None) 
      							 
      RISULTATI:
      * .../IFFunctions/tt contiene il file 'info.fits' con i dati utilizzati per creare le iff 
      	e gli interferogrammi acquisiti
      * .../CommandHistory/tt contiene il file 'info.fits' in cui sono salvati i dati con cui è stata 
      	creata la matrice con la storia dei comandi
      	
      	
     - Analisi
     
       PROCEDIMENTO:
       from m4.analyzer_iffunctions import AnalyzerIFF 
       fileName = os.path.join(".../IFFunctions", tt)
  	   an = AnalyzerIFF.loadInfoFromTtFolder(fileName)
  	   cube = an.createCube(tiptiltDetrend=None, phaseAmbiguity=None)
  	   an.saveCubeAsFits(cubeName)	#'Cube.fits' or 'CubeTTD.fits' etc..
  	   ( intMat= an.getInteractionMatrix()	rec= an.getReconstructor() 	)
  	   
  	   RISULTATI:
  	   * .../IFFunctions/tt contiene il cubo con le funzioni di influenze ridotte nel modo richiesto
  	   * an è definito tramite le IFF scelte e può essere usato per lo spianemento
  	   
  	   
• Spianamento
  	 
  	   PROCEDIMENTO:
  	   from m4.analyzer_iffunctions import AnalyzerIFF
  	   an = AnalyzerIFF.loadInfoFromTtFolder(fileName)
  	   from m4.flattening import Flattenig
  	   fl = Flattening(an)
  	   cmd = fl.flatCommand(wf)
  	   
  	   RISULTATI:
  	   
  	   
  	   
• Calibrazione e allineamento delle ottiche 

	
	- Allineamento dell'OTT (PAR + RM)
	
	  PROCEDIMENTO:
	  from m4.alignment import Alignment 
	  a = Alignment()
	  tt = a.ott_calibration(commandAmpVector, nPushPull, maskIndex)
	  cmd = a.ott_alignment(tt)
	  
	  RISULTATI:
	  
	  
	- Allinemaneto di M4
	
	  PROCEDIMENTO:
	  from m4.alignment import Alignment 
	  a = Alignment()
	  tt, zCoefComa, comaSurface = a.m4_calibration(...)
      cmd = a.m4_alignement(zCoefComa)
	  
	  RISULTATI:
	  
	 

	  
• Ricostruzione degli zernike su tutto m4

	  PROCEDIMENTO:
	  from m4 import sandbox
	  seg = sandbox.immaginiDaIFFRuna()
	  from m4.utils.roi import ROI
      r = ROI()
	  roi = r.roiGenerator(seg)
	  from m4.zernike_command_test import ZernikeCommand
      zc = ZernikeCommand(roi[3], tt_list_for_an)
      tt, surf_cube, image_cube = zc.zernikeCommandTest(zernike_modes_vector_amplitude)
      		
	  
	  RISULTATI:	  
	  * .../ZernikeCommandTest/tt contiene
	  tutte le misure effettuate (mode000i_measure_segment0i_neg(pos).fits),
	  il comando totale relativo al modo (total_command_mode0002.fits),
	  il cubo del modo, cioè le immagini dei 6 segmenti, (cube_mode0004.fits)
	  il cubo delle superficie di zernike usate (surfCube.fits),
	  il cubo delle immagini totali su m4 (m4ImageCube.fits).



• SW per gli SPL

	  PROCEDIMENTO:
	  from m4.SPL_controller import SPL
	  #definizione dell'oggetto filtro e dell'oggetto camera
	  spl = SPL(filtro, camera)
	  lambda_vector = np.arange(530,730,10)
	  piston = spl.measurement(lambda_vector, acq4d=None, an=None)
	  
	  oppure solo: piston = spl.analyzer(tt)


	  RISULTATI:
	  * .../SPL/ tt contiene
	  tutte le misure effettuate (image_530nm.fits),
	  lambda_vector.fits
	  piston_result.txt
	  fringe_result.fits (la mia matrice totale 151xn_lambda)

• Noise
	 PROCEDIMENTO:
	 from m4.noise_functions import Noise
	 n = Noise()
	 #acquisizione dati e analisi (es: template=np.array([1,-1,1]) numberOfNoiseIma=3*3*25=225)
	 destination_file_path, rms_mean = n.noise_acquisition_and_analysis(numberOfNoiseIma, template)
	 #analisi di più carrtelle di dati
	 rms_medio, n_temp = n.different_template_analyzer(tt_list)

	 RISULTATI:
	 rms_medio, n_temp = vettore degli rms medi e lunghezza dei template ustai per poter farci il plot
	 * .../Noise/ tt contiene
	 il file con le info usate per fare le iff (info.fits)
	 il cubo di misure prese con le iff (misere.fits)
	 il cubo che viene dall'analisi delle iff con l'analyzer (Cube.fits)
	
	